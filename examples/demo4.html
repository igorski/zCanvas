<!DOCTYPE html>
<html>
<head>
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable = no" name="viewport">
    <meta charset="utf-8" />
    <title>zCanvas integrating third party animation libraries example</title>
    <link rel="stylesheet" href="./assets/styles.css">
    <script type="text/javascript" src="./assets/images.js"></script>
    <!-- include RequireJS to resolve dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.14/require.min.js" type="text/javascript"></script>
    <!-- include Greensock TweenMax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.0/TweenMax.min.js" type="text/javascript"></script>
</head>
<body>
    <div id="container">
        <h1>zCanvas demo #4: Animating using 3rd party libraries</h1>
        <div id="demo"><!-- x --></div>
        <p>
            Demo features : multiple Sprites, each moving using different easing functions from the
            Greensock TweenMax library. The star shape also acts as a mask for an underlying photo.
        </p>
    </div>
    <script type="text/javascript">

        // resolve dependencies

        requirejs.config({
            baseUrl : "../dist/",
            urlArgs : "bust=" + Date.now()
        });

        require( [ "zcanvas.umd" ], zCanvas => {

            const { Canvas, Sprite } = zCanvas;

            // STEP 1 : SETUP
            // --------------------------------------

            const container = document.getElementById( "demo" );

            // get window dimensions

            let w, h;
            if ( window.outerHeight ) {
                w = window.outerWidth;
                h = window.outerHeight;
            }
            else {
                w = document.body.clientWidth;
                h = document.body.clientHeight;
            }

            // create a new canvas that renders at 60 fps
            // keep it within the device / browser bounds
            const cvsWidth  = ( w < 800 ) ? w * .93 : 800;
            const cvsHeight = ( h < 500 ) ? h : 500;
            const cvs = new Canvas({
                width: cvsWidth,
                height: cvsHeight,
                animate: true,
                fps: 60,
                preventEventBubbling: true,
                parentElement: container
            });

            // register assets

            Promise.all([
                cvs.loadResource( "background", IMAGE_BACKGROUND ),
                cvs.loadResource( "star", IMAGE_STAR ),
            ]);

            const cvsCenterX = cvs.getWidth()  / 2;
            const cvsCenterY = cvs.getHeight() / 2;

            // STEP 2 : ADDING THE SPRITES
            // ---------------------------

            // first sprite will act as a background
            // (see included "assets.js"-file for the assetBackground-image data)

            const bgWidth  = 800;
            const bgHeight = 1067;
            const bgSprite = new Sprite({ width: bgWidth, height: bgHeight, resourceId: "background" });
            
            cvs.addChild( bgSprite );   // add the background to the canvas so it is visible

            // RESIZING MASK SPRITE
            // --------------------
            // a sprite that will act as a mask for underlying content
            // (see included "images.js"-file for the assetStar-image data)

            const starSize = cvsWidth * .3; // make the star slightly smaller than the canvas
            const spriteMask = new Sprite({
                x: cvsCenterX - starSize / 2,
                y: cvsCenterY - starSize / 2,
                width: starSize,
                height: starSize,
                resourceId: "star",
                mask: true
            });

            const starBounds = spriteMask.getBounds();    // the stars properties we will be tweening
            const stl = new TimelineMax({ repeat: 999 }); // timeline for the star

            const doubleSize = starSize * 2;

            stl.to(
                starBounds, 2, {
                    left: "-=" + ( doubleSize / 2 ),
                    top: "-=" + ( doubleSize / 2 ),
                    height: "+=" + doubleSize,
                    width: "+=" + doubleSize,
                    ease: Elastic.easeInOut
                }
            ).to(
                starBounds, 2, { left: "+=" + ( doubleSize / 2), top: "+=" + ( doubleSize / 2),
                        width: "-=" + doubleSize, height: "-=" + doubleSize, ease: Power4.easeIn }
            );
            cvs.addChild( spriteMask ); // add star making sprite to canvas so it is visible

            // ANIMATING CIRCLES
            // aPositionRadius defines the radius of the circle all circles will be aligned to
            // aSizeRadius defines the radius of the circles bounds

            class CircleSprite extends Sprite {
                constructor( x, y, aPositionRadius, aSizeRadius, aColor ) {
                    super({
                        x: x - aPositionRadius * 2,
                        y: y - aPositionRadius * 1.5,
                        width: aPositionRadius * 2,
                        height: aPositionRadius * 2
                    });

                    /* instance properties */

                    this.radius = aSizeRadius;
                    this.color = aColor;

                    this.setDraggable( true );
                }

                /* overridden zCanvas.sprite methods */

                // here we override the getters and setters to accommodate for the radius of the circle as
                // the circles center point is the x- and y-coordinate to provide from-center-snapping

                getX() {
                    return super.getX() + this.getWidth();
                }

                getY() {
                    return super.getY() + this.getHeight();
                }

                draw( renderer ) {
                    renderer.drawCircle(
                        this.getX(), this.getY(), this.radius,
                        this.hover ? "#FFFFFF" : this.color, // when hovering the circle is white
                        this.hover ? "#FF9900" : undefined, // when hovering we add an outline to the circle
                    );
                    super.draw( renderer ); // will invoke the drawing of nested child elements
                }
            };

            // helper function to calculate x, y coordinate of each CircleSprite

            function calcPosition( radius, angle ) {
                return {
                    x: cvsCenterX + radius * Math.cos( angle * Math.PI / 180 ),
                    y: cvsCenterY + radius * Math.sin( angle * Math.PI / 180 )
                }
            }
            const positionRadius = 100; // radius of the circles position
            const radius = 7;           // radius of the circles size

            // generate the circle sprites

            for ( let i = 0, total = 50; i < total; ++i ) {

                /// calc x and y position with radius of center +
                const angle = i * ( 360 / total );
                const targetPosition = calcPosition( positionRadius, angle );
                const scaledPosition = calcPosition( positionRadius * 2, angle );

                // note we construct all circles from the center of the canvas
                const cs = new CircleSprite( cvsCenterX, cvsCenterY, 7, radius, "#FF00AE" );

                // each circle sprite has its own timeline where it moves form the canvas
                // center to its unique position, and back to the center again, each sprite
                // starts at a different time from the other (see "delay")

                new TimelineMax({ repeat: 999 }).
                    to( cs.getBounds(), 2, {
                        left: targetPosition.x, top: targetPosition.y, ease: Power4.easeInOut, delay: ( i * .1 )
                    }).
                    to( cs.getBounds(), 2, {
                        left: scaledPosition.x,
                        top:  scaledPosition.y,
                        ease: Elastic.easeIn,
                        delay: ( i * .1 )
                    }).to(
                        cs.getBounds(), 2, {
                            left: cvsCenterX,
                            top: cvsCenterY,
                            ease: Elastic.easeOut
                        }
                    );

                // add circle sprite to canvas so we can see it
                cvs.addChild( cs );
            }
        });

    </script>
</body>
</html>
