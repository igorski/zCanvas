<!DOCTYPE html>
<html>
<head>
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable = no" name="viewport">
    <meta charset="utf-8" />
    <title>zCanvas animated spritesheet example</title>
    <!-- load demo assets -->
    <link rel="stylesheet" href="./assets/styles.css">
    <script type="text/javascript" src="./assets/images.js"></script>
    <script type="text/javascript" src="./assets/utils.js"></script>
</head>
<body>
<div class="demo-container">
    <div class="demo-header">
        <h1>zCanvas : spritesheets and collisions</h1>
    </div>
    <div class="demo-canvas-container"><!-- x --></div>
    <div class="demo-controls">
        <div>
            <label for="fps">Framerate (15 to 60 fps)</label>
            <input type="range" id="fps" min="15" max="60" value="60" step="1" />
        </div>
        <button type="button" id="fullscreen">Fullscreen</button>
    </div>
    <p class="demo-description">
        Demo features : a keyboard / touchscreen-controllable spritesheet character that uses the pixel-accurate (and slightly heavier) collision
        detection-variant (see API docs) to resolve collisions with the environment. The simulation speed is locked to the configured canvas framerate.
        Use arrow keys and spacebar to jump.
    </p>
</div>
<script type="module">
import { Canvas, Sprite } from "../dist/zcanvas.mjs";

// STEP 1 : SETUP
// --------------------------------------

const demoContainer   = document.querySelector( ".demo-container" );
const canvasContainer = document.querySelector( ".demo-canvas-container" );

const cvsWidth  = 800;
const cvsHeight = 350;

const cvs = new Canvas({
    width: cvsWidth,
    height: cvsHeight,
    animate: true,
    smoothing: false, // pixel art ahoy
    fps: 60,
    preventEventBubbling: true,
    parentElement: canvasContainer,
    onResize: ( width, height ) => {
        // resize demo container to accomodate the canvas size
        demoContainer.style.width = `${width}px`;
    }
});
addCanvasDemoControls( demoContainer, cvs );

// STEP 2: REGISTER ASSETS
// -----------------------

Promise.all([
    cvs.loadResource( "background",  IMAGE_BACKGROUND ),
    cvs.loadResource( "spritesheet", IMAGE_SPRITE_SHEET ),
    cvs.loadResource( "level", IMAGE_LEVEL )
])
.then( async () => {    
    // STEP 3 : SELF ANIMATING IMAGE EXAMPLE
    // --------------------------------------

    // first sprite will act as a background
    // (see included "assets.js"-file for the assetBackground-image data)

    const bgWidth  = 800;
    const bgHeight = 1067;
    const bgSprite = new Sprite({
        width: bgWidth,
        height: bgHeight,
        resourceId: "background",
    });

    // add the sprite onto the canvas so we can see it
    cvs.addChild( bgSprite );

    // STEP 3 : NEW SUBCLASS / SPRITESHEET EXAMPLE
    // -------------------------------------------
    // when writing your application using OOP-paradigms, it makes
    // more sense to create new "classes" for custom sprite Objects, like such:

    class Hero extends Sprite {
        constructor( opts ) {
            super( opts );

            /* Hero instance properties */

            this.direction       = 0;     // 0 = left, 1 = right
            this.running         = false; // is the hero running ?
            this.jumping         = false; // is the hero jumping ?
            this.falling         = true;  // is the hero falling ? (set to true for gravity)
            this.xSpeed          = 0;     // horizontal speed (i.e. walking)
            this.MAX_X_SPEED     = 5;     // maximum horizontal speed in pixels per frame
            this.SPEED_INCREMENT = 0.125; // the value with which we will increment the speed until it reaches MAX
            this.FRICTION        = 0.25;
            this.GRAVITY         = 7;     // the vertical "pull" exerted on the Hero
            this.ySpeed          = 0;     // vertical speed (i.e. jumping/falling)
            this._jumpCount      = 0;     // internal : countdown for determining max jump height reached
        }

        /* public methods */

        jump() {
            if ( this.jumping ) {
                return;
            }
            this.ySpeed     = 5;
            this._jumpCount = 10;
            this.jumping    = true;
            this.falling    = false;
        }

        // makes the hero run left (0) or right (1) at incremental speed

        run( direction ) {
            this.direction = direction;
            this.running   = true;
            // switch spritesheet animation now we're starting to run
            this.switchAnimation(
                ( this.direction === 0 ) ? 2 : 3
            );
        }

        // stops the hero (will slowly move to a halt)

        stop() {
            this.running = false;
            // switch spritesheet animation now we're stopping the running
            this.switchAnimation( this.direction === 0  ? 0 : 1 );
        }

        // methods overriden from Sprite prototype for custom behaviour
        // --------------------------------------------------------------------

        update( timestamp, framesSinceLastUpdate ) {

            // animation update operations (i.e. switch tile in sheet)

            this.updateAnimation( framesSinceLastUpdate );

            // movement

            if ( this.running ) {
                if ( this.direction === 0 ) { // moving left
                    if ( hero.xSpeed > -hero.MAX_X_SPEED ) {
                        hero.xSpeed -= ( this.SPEED_INCREMENT * framesSinceLastUpdate );
                    }
                }
                else if ( this.direction === 1 ) { // moving right
                    if ( hero.xSpeed < hero.MAX_X_SPEED ) {
                        hero.xSpeed += ( this.SPEED_INCREMENT * framesSinceLastUpdate );
                    }
                }
            }

            const thisWidth  = this.getWidth();
            const thisHeight = this.getHeight();
            const prevX = this.getX();
            const prevY = this.getY();
            let targetX = prevX;
            let targetY = prevY;
            
            // are we moving horizontally ?

            if ( this.xSpeed > this.FRICTION || this.xSpeed < -this.FRICTION ) {

                targetX += this.xSpeed * framesSinceLastUpdate;

                // keep in bounds (exiting screen on left/right result in appearing on right/left)

                if ( targetX > ( cvsWidth + thisWidth )) {
                    targetX = -thisWidth;
                }
                if ( targetX < -thisWidth ) {
                    targetX = cvsWidth + thisWidth - 1;
                }
            }

            // are we moving vertically ? (e.g. falling or jumping)

            if ( !this.falling && this.jumping ) {
                targetY -= ( this.ySpeed * framesSinceLastUpdate );
            } else {
                targetY += ( this.GRAVITY * framesSinceLastUpdate );
            }

            // constrain Hero within the vertical bounds of the canvas
            if ( targetY > this.canvas.getHeight() + thisHeight ) {
                targetY = -thisHeight;
            }
            const movingLeft = ( targetX < prevX );

            // collision detection with the wall/floor Sprite
            let horizontalCollision, verticalCollision;

            this.setX( targetX );
            if ( horizontalCollision = cvs.collision.pixelCollision( this, wallSprite, true )) {
                // horizontal collision, e.g. touched wall
                // link to wall by taking the current position plus the
                // x-index of the collision minus the total width of the sprite
                targetX = this.getX() + horizontalCollision.x - thisWidth;
                this.setX( prevX );//targetX );
            }

            this.setY( targetY );
            if ( verticalCollision = cvs.collision.pixelCollision( this, wallSprite, true )) {
                // vertical collision, e.g. touched ground or bumped head
                // link to ground by taking the current position plus the
                // y-index of the collision minus the total height of the sprite
                if ( verticalCollision.y < thisHeight / 2 ) {
                    this.setY( prevY );
                } else {
                    this.setY( this.getY() + verticalCollision.y - thisHeight );
                }
                this.jumping = false;
            }

            // in case the user has stopped moving the hero, we
            // slowly reduce the heros speed so he doesn't stop at once

            if ( !this.running ) {
                if ( this.xSpeed < 0 ) {
                    this.xSpeed += this.FRICTION;
                } else if ( this.xSpeed > 0 ) {
                    this.xSpeed -= this.FRICTION;
                }
            }

            // in case the user has stopped holding the jump button down, we
            // slowly reduce the heros speed so he falls back down

            if ( this.jumping && !this.falling ) {
                this._jumpCount -= framesSinceLastUpdate;
                if ( this._jumpCount <= 0 ) {
                    this.falling = true;
                }
            }
        }
    }

    // create a new Hero instance and add it to the stage
    // our spritesheet is 380 x 70 pixels with each individual tile
    // in the sheet being 38 x 35 pixels. There is one row for each animation, there
    // are four rows in total. (see included "images.js"-file for the assetSpriteSheet-image data)

    const tileWidth = 38;
    const tileHeight = 35; // height of a single tile
    const hero = new Hero({
        x: 100,
        y: 0, // fall from the sky
        width: tileWidth,
        height: tileHeight,
        resourceId: "spritesheet",
        sheet: [
            { row: 0, col: 0, fpt: 5, amount: 3 },  // standing still, facing left
            { row: 1, col: 0, fpt: 5, amount: 3 },  // standing still, facing right
            { row: 2, col: 0, fpt: 3, amount: 10 }, // running, facing left
            { row: 3, col: 0, fpt: 3, amount: 10 }  // running facing right
        ]
    });
    cvs.addChild( hero );

    // STEP 4 : ADD SOME WALLS AND FLOORS
    // ----------------------------------

    const wallImageWidth = 660;
    const wallImageHeight = 261;
    const wallSprite = new Sprite({
        x: cvsWidth / 2 - wallImageWidth / 2,
        y: 50,
        width  : wallImageWidth,
        height : wallImageHeight,
        resourceId: "level",
    });
    cvs.addChild( wallSprite );

    // cache the bitmap resources
    await Promise.all([
        cvs.getResource( "level" ),
        cvs.getResource( "spritesheet" ),
    ]);
    // cache the player and level bitmaps to speed up pixel based collision detection
    await Promise.all([
        cvs.collision.cache( "level" ),
        cvs.collision.cache( "spritesheet" ),
    ]);

    // STEP 5 : ADDING KEYBOARD AND TOUCH INTERACTION
    // ----------------------------------------------

    // we add on-screen controls buttons for touch screens

    createJoypad(
        canvasContainer,
        // left button down and release handler
        () => hero.run( 0 ), () => hero.stop(),
        // right button down and release handler
        () => hero.run( 1 ), () => hero.stop(),
        // action button down and release handler
        () => hero.jump(), () => {}
    );

    // keyboard control for desktop devices

    const blockedCodes = [ 32, 38, 40, 37, 39 ]; // keycodes to block default behaviour of

    window.addEventListener( "keydown", e => {
        switch ( e.key ) {
            // move up (jump)
            case " ":
                hero.jump();
                break;

            // move hero to the right
            case "ArrowRight":
                if ( !hero.running ) {
                    hero.run( 1 );
                }
                break;

            // move hero to the left
            case "ArrowLeft":
                if ( !hero.running ) {
                    hero.run( 0 );
                }
                break;
        }
        if ( blockedCodes.includes( e.keyCode )) {
            e.preventDefault(); // prevents document panning (if Canvas doesn't fit entirely)
        }
    });

    // add a listener for key up (release) so we can tell the hero to stop running

    window.addEventListener( "keyup", e => {
        if ( e.keyCode == 39 || e.keyCode == 37 ) {
            hero.stop();
        }
    });
});
</script>
</body>
</html>
